#!/usr/bin/env python3
"""
Advanced meditative MIDI generator.
Exports SMF type 1 MIDI (bytes) ready for DAW import (Logic-compatible).
- Creates tempo/time/key meta events
- Creates markers for phrase starts
- Exports Melody track, Chords/Pad track, and Tempo/Marker track
- Adds program changes and sustain/expression CCs
"""
from __future__ import annotations
from typing import List, Tuple, Dict, Any
import mido
from io import BytesIO
import random
import math
import time

PPQ = 480
BEATS_PER_BAR = 4

NOTE_TO_SEMI = {
    'C':0,'C#':1,'Db':1,'D':2,'D#':3,'Eb':3,'E':4,'F':5,'F#':6,'Gb':6,'G':7,'G#':8,'Ab':8,'A':9,'A#':10,'Bb':10,'B':11
}

SCALE_INTERVALS = {
    'major':[2,2,1,2,2,2,1],
    'minor':[2,1,2,2,1,2,2],
    'pentatonic':[2,2,3,2,3],
    'dorian':[2,1,2,2,2,1,2],
    'lydian':[2,2,2,1,2,2,1],
    'phrygian':[1,2,2,2,1,2,2],
    'harmonic':[2,1,2,2,1,3,1]
}

def note_name_to_midi(name:str, octave:int)->int:
    n = name.strip().capitalize()
    if len(n)>1 and n[1] in ['#','b']:
        n = n[0].upper()+n[1]
    semi = NOTE_TO_SEMI.get(n)
    if semi is None:
        raise ValueError("Unknown note name: "+name)
    return 12*(octave+1)+semi

def build_scale_notes(root:str, scale:str, min_oct=3, max_oct=6)->List[int]:
    if scale not in SCALE_INTERVALS:
        raise ValueError("Unknown scale")
    intervals = SCALE_INTERVALS[scale]
    offsets = [0]
    for st in intervals:
        offsets.append(offsets[-1]+st)
    if offsets[-1] == 12:
        offsets = offsets[:-1]
    notes=[]
    for octv in range(min_oct, max_oct+1):
        root_m = note_name_to_midi(root, octv)
        for off in offsets:
            m = root_m + off
            if 0<=m<=127:
                notes.append(m)
    notes = sorted(set(notes))
    return notes

def ticks_from_beats(beats: float)->int:
    return int(round(beats*PPQ))

def make_rng(seed=None):
    r = random.Random(seed)
    return r

def choose_interval(rng: random.Random):
    items=[(-4,1),(-3,2),(-2,6),(-1,10),(0,4),(1,10),(2,6),(3,3),(4,2),(5,1),(7,0.5),(-7,0.5)]
    total = sum(w for _,w in items)
    r = rng.random()*total
    for val,w in items:
        if r < w:
            return int(val)
        r -= w
    return 1

def generate_rhythm(total_beats:float, rng:random.Random):
    pool = [1.0,2.0,3.0,4.0,0.5]  # favor long durations
    out=[]
    rem = total_beats
    attempts=0
    while rem > 1e-6 and attempts < 2000:
        choices = [d for d in pool if d <= rem + 1e-9]
        if not choices:
            out.append(rem); break
        weights = [d for d in choices]
        s = sum(weights)
        r = rng.random()*s
        acc=0
        chosen=choices[0]
        for i,w in enumerate(weights):
            acc += w
            if r <= acc:
                chosen = choices[i]; break
        out.append(chosen)
        rem -= chosen
        attempts += 1
    return out

def generate_melody(scale_notes:List[int], bars:int, rng:random.Random)->List[Dict[str,Any]]:
    total_beats = bars * BEATS_PER_BAR
    rhythm = generate_rhythm(total_beats, rng)
    notes = scale_notes[:]
    idx = len(notes)//2
    if rng.random() < 0.5:
        idx += rng.choice([-1,0,1])
    idx = max(0, min(idx, len(notes)-1))
    melody=[]
    motif=[]
    t = 0.0
    for dur in rhythm:
        # sometimes repeat motif
        if motif and rng.random() < 0.15:
            # repeat motif (with minor variation)
            for n,d in motif[:3]:
                vel = int(70 + rng.random()*20)
                melody.append({'start':t, 'dur':min(d, dur), 'midi':n, 'vel':vel})
                t += min(d,dur)
            motif=[]
            continue
        interval = choose_interval(rng)
        idx = max(0, min(idx+interval, len(notes)-1))
        midi_note = notes[idx]
        # occasional octave scatter
        if rng.random() < 0.06:
            midi_note = midi_note + (12 if rng.random()<0.5 else -12)
            if midi_note < 0: midi_note = notes[idx]
            if midi_note > 127: midi_note = notes[idx]
        vel = int(72 + rng.random()*24)
        # create slight overlap for legato: we'll schedule note_on slightly before previous note_off
        melody.append({'start':t, 'dur':dur, 'midi':midi_note, 'vel':vel})
        if rng.random() < 0.12 and len(motif) < 6:
            motif.append((midi_note, dur))
        t += dur
    # final resolution note
    if rng.random() < 0.8:
        mid = notes[len(notes)//2]
        melody.append({'start':t, 'dur':BEATS_PER_BAR, 'midi':mid, 'vel':80})
    return melody

def triad_from_degree(scale_notes:List[int], degree:int, base_idx_offset=0)->List[int]:
    # scale degrees considered modulo single-octave of scale (best-effort)
    # pick root index near middle then degree offset
    base_idx = max(0, len(scale_notes)//2 - 3) + base_idx_offset
    idx = min(len(scale_notes)-1, max(0, base_idx + degree))
    root = scale_notes[idx]
    third = scale_notes[min(len(scale_notes)-1, idx+2)]
    fifth = scale_notes[min(len(scale_notes)-1, idx+4)]
    # add9 (optional) one scale step above root, up an octave if needed
    add9 = None
    if idx+1 < len(scale_notes):
        cand = scale_notes[idx+1]
        if cand - root < 8:  # avoid too-close
            add9 = cand + 12
        else:
            add9 = cand
    chord = [root, third, fifth]
    if add9 and add9 < 128:
        chord.append(add9)
    return chord

def generate_chords(scale_notes:List[int], bars:int, density:int, rng:random.Random)->List[Dict[str,Any]]:
    changes = bars * density
    palette = [[0,5,3,4],[0,3,4,0],[0,4,3,0]]
    choice = rng.choice(palette)
    prog=[]
    i=0
    while len(prog) < changes:
        prog.append(choice[i % len(choice)])
        i += 1
    chords=[]
    dur = BEATS_PER_BAR / density
    t=0.0
    for deg in prog:
        tri = triad_from_degree(scale_notes, deg % 7, base_idx_offset=0)
        chords.append({'start':t, 'dur':dur, 'notes':tri})
        t += dur
    return chords

def build_markers(bars:int, structure_names:List[str]=None):
    # return markers at bar starts with labels (Intro, A, B, Outro ...)
    markers=[]
    if structure_names is None:
        structure_names = ['Intro','Section A','Bridge','Section A\'','Outro']
    # distribute sections across bars
    n_sections = len(structure_names)
    # ensure at least 1 bar per section
    sizes = []
    base = max(1, bars // n_sections)
    rem = bars - base*n_sections
    for i in range(n_sections):
        add = 1 if i < rem else 0
        sizes.append(base + add)
    bar = 0
    for i,name in enumerate(structure_names):
        markers.append({'bar':bar+1, 'label':name})
        bar += sizes[i]
        if bar >= bars:
            break
    return markers

def generate_song_structure(key='C', scale='pentatonic', bars=8, bpm=44, density=1, seed=None)->Dict[str,Any]:
    rng = make_rng(seed)
    seed_val = seed if seed is not None else int(time.time())
    structure = {'seed': seed_val, 'key':key, 'scale':scale, 'bars':bars, 'bpm':bpm}
    scale_notes = build_scale_notes(key, scale, min_oct=3, max_oct=6)
    melody = generate_melody(scale_notes, bars, rng)
    chords = generate_chords(scale_notes, bars, density, rng)
    markers = build_markers(bars)
    structure.update({'melody':melody, 'chords':chords, 'markers':markers, 'scale_notes':scale_notes})
    return structure

def generate_song_midi(structure:Dict[str,Any])->bytes:
    # create SMF type=1
    bpm = structure.get('bpm', 44)
    key = structure.get('key', 'C')
    bars = structure.get('bars', 8)
    melody = structure.get('melody', [])
    chords = structure.get('chords', [])
    markers = structure.get('markers', [])
    mid = mido.MidiFile(type=1, ticks_per_beat=PPQ)
    # meta track
    meta = mido.MidiTrack()
    mid.tracks.append(meta)
    meta.append(mido.MetaMessage('track_name', name='Tempo & Markers', time=0))
    meta.append(mido.MetaMessage('set_tempo', tempo=mido.bpm2tempo(bpm), time=0))
    meta.append(mido.MetaMessage('time_signature', numerator=BEATS_PER_BAR, denominator=4, clocks_per_click=24, notated_32nd_notes_per_beat=8, time=0))
    meta.append(mido.MetaMessage('key_signature', key=key, time=0))
    # markers: we add marker meta events at bar starts (with correct delta times)
    total_bars = bars
    current_tick = 0
    for m in markers:
        bar_index = m.get('bar',1)-1
        tick = int(bar_index * BEATS_PER_BAR * PPQ)
        delta = int(tick - current_tick)
        if delta < 0: delta = 0
        meta.append(mido.MetaMessage('marker', text=m.get('label',''), time=delta))
        current_tick = tick
    # melody track (channel 0)
    mel_track = mido.MidiTrack()
    mid.tracks.append(mel_track)
    mel_track.append(mido.MetaMessage('track_name', name='Melody', time=0))
    mel_track.append(mido.Message('program_change', program=0, channel=0, time=0))
    # expression start
    mel_track.append(mido.Message('control_change', control=11, value=90, channel=0, time=0))
    # build events list (tick, message)
    events = []
    for note in melody:
        start_tick = ticks_from_beats(note['start'])
        off_tick = start_tick + ticks_from_beats(note['dur'])
        # To create legato/overlap: let next note_on sometimes appear slightly before previous off,
        # but here we keep exact beats; DAW legato can be set on import.
        events.append((start_tick, mido.Message('note_on', note=int(note['midi']), velocity=int(note['vel']), channel=0)))
        events.append((off_tick, mido.Message('note_off', note=int(note['midi']), velocity=0, channel=0)))
    events.sort(key=lambda x:x[0])
    last = 0
    for tick,msg in events:
        delta = tick - last
        if delta < 0: delta = 0
        m = msg.copy(time=delta)
        mel_track.append(m)
        last = tick
    # chord/pad track (channel 1)
    chord_track = mido.MidiTrack()
    mid.tracks.append(chord_track)
    chord_track.append(mido.MetaMessage('track_name', name='Chords/Pad', time=0))
    chord_track.append(mido.Message('program_change', program=89, channel=1, time=0))  # pad-like
    chord_track.append(mido.Message('control_change', control=64, value=127, channel=1, time=0))  # sustain on
    events_ch = []
    for ch in chords:
        st = ticks_from_beats(ch['start'])
        off = st + ticks_from_beats(ch['dur'])
        for n in ch['notes']:
            events_ch.append((st, mido.Message('note_on', note=int(n), velocity=80, channel=1)))
            events_ch.append((off, mido.Message('note_off', note=int(n), velocity=0, channel=1)))
    events_ch.sort(key=lambda x:x[0])
    last = 0
    for tick,msg in events_ch:
        delta = tick - last
        if delta < 0: delta = 0
        chord_track.append(msg.copy(time=delta))
        last = tick
    # release sustain at very end
    chord_track.append(mido.Message('control_change', control=64, value=0, channel=1, time=PPQ))
    # save to bytes
    buf = BytesIO()
    mid.save(file=buf)
    return buf.getvalue()
